<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="FixMe" BeforeTargets="BeforeBuild">
    <ItemGroup Condition=" '@(FixMeTokens)' == '' ">
      <FixMeTokens Include="BUG;FIXME;HACK;UNDONE;NOTE;OPTIMIZE;TODO;WORKAROUND;XXX;UnresolvedMergeConflict" />
    </ItemGroup>
    <ItemGroup>
      <FixMeItemNames Include="@(AvailableItemName)" />
      <FixMeItemNames Include="ApplicationDefinition;AdditionalFiles;Compile;Content;DesignData;DesignDataWithDesignTimeCreatableTypes;EmbeddedResource;EntityDeploy;None;Page;Resource;SplashScreen" />
    </ItemGroup>
    <ItemGroup>
      <FixMeFiles Include="@(%(FixMeItemNames.Identity))" Exclude="$(FixMeExclude)" />
    </ItemGroup>
    <TokenSearch Files="@(FixMeFiles)" Tokens="@(FixMeTokens)" />
  </Target>
  <UsingTask TaskName="TokenSearch" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v12.0.dll">
    <ParameterGroup>
      <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Tokens ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Fragment" Language="cs">
<![CDATA[
var regexBuilder = new StringBuilder();
foreach (var token in Tokens)
{
    if (regexBuilder.Length > 0)
    {
        regexBuilder.Append("|");
    }

    regexBuilder.Append(Regex.Escape(token.ItemSpec));
}

var tokensRegex = new Regex(regexBuilder.ToString(), RegexOptions.Compiled);
var singleLineCommentRegex = new Regex(@"(?://|--|#|'|REM|::)\s*$", RegexOptions.Compiled);
var multiLineCommentStartRegex = new Regex(@"(/\*+|<#|<!--+|@\*+)\s*$", RegexOptions.Compiled);
var stringStartRegex = new Regex(@"(@?"")\s*$", RegexOptions.Compiled);
var extractCharsVerbatimRegex = new Regex(@"((?<char>[^""])|""(?<char>""))*", RegexOptions.Compiled);
var extractCharsEscapedRegex = new Regex(@"((?<char>[^\\""])|\\(?<char>[""'])|(?<char>\\.))*", RegexOptions.Compiled);

foreach (var file in Files)
{
    var fileName = file.ItemSpec;

    if (!File.Exists(fileName))
    {
        Log.LogMessage(MessageImportance.Normal, "Skipping '{0}' because it was not found.", fileName);
        continue;
    }

    using (var fileStream = File.OpenRead(fileName))
    {
        var isBinary = false;
        var header = new byte[1024];
        var read = fileStream.Read(header, 0, header.Length);
        for (var i = 0; i < read; i++)
        {
            if (header[i] == 0)
            {
                isBinary = true;
                break;
            }
        }

        if (isBinary)
        {
            Log.LogMessage(MessageImportance.Normal, "Skipping '{0}' because it appears to be a binary file.", fileName);
            continue;
        }

        fileStream.Seek(0, SeekOrigin.Begin);
        using (var reader = new StreamReader(fileStream))
        {
            var lineNumber = 0;
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                lineNumber++;
                foreach (Match match in tokensRegex.Matches(line))
                {
                    var startColumn = match.Index + 1;
                    var endColumn = startColumn + match.Length;
                    var tokenEndIndex = match.Index + match.Length;

                    var token = match.Value;
                    var found = false;
                    string message = null;

                    var prefix = line.Substring(0, match.Index);
                    foreach (Match singleLineMatch in singleLineCommentRegex.Matches(prefix))
                    {
                        if (string.IsNullOrWhiteSpace(prefix.Substring(singleLineMatch.Index + singleLineMatch.Length)))
                        {
                            found = true;
                            message = line.Substring(tokenEndIndex);
                            break;
                        }
                    }

                    if (string.IsNullOrEmpty(message))
                    {
                        foreach (Match multiLineMatch in multiLineCommentStartRegex.Matches(prefix))
                        {
                            if (string.IsNullOrWhiteSpace(prefix.Substring(multiLineMatch.Index + multiLineMatch.Length)))
                            {
                                string terminator = null;
                                switch (multiLineMatch.Groups[1].Value)
                                {
                                    case "/*":
                                        terminator = "*/";
                                        break;
                                    case "@*":
                                        terminator = "*@";
                                        break;
                                    case "<#":
                                        terminator = "#>";
                                        break;
                                    case "<!--":
                                        terminator = "-->";
                                        break;
                                }

                                var terminatorIndex = line.IndexOf(terminator, tokenEndIndex);
                                if (terminatorIndex == -1)
                                {
                                    found = true;
                                    message = line.Substring(tokenEndIndex);
                                    break;
                                }
                                else
                                {
                                    found = true;
                                    message = line.Substring(tokenEndIndex, terminatorIndex - tokenEndIndex);
                                    break;
                                }
                            }
                        }

                        if (string.IsNullOrEmpty(message))
                        {
                            foreach (Match stringMatch in stringStartRegex.Matches(prefix))
                            {
                                if (string.IsNullOrWhiteSpace(prefix.Substring(stringMatch.Index + stringMatch.Length)))
                                {
                                    Regex extractRegex = null;
                                    switch (stringMatch.Groups[1].Value)
                                    {
                                        case @"@""":
                                            extractRegex = extractCharsVerbatimRegex;
                                            break;
                                        case @"""":
                                            extractRegex = extractCharsEscapedRegex;
                                            break;
                                    }

                                    found = true;
                                    message = string.Concat(extractRegex.Match(line.Substring(tokenEndIndex)).Groups["char"].Captures.Cast<Capture>());
                                    break;
                                }
                            }
                        }
                    }

                    if (found)
                    {
                        if (string.IsNullOrWhiteSpace(message))
                        {
                            Log.LogWarning(null, null, null, fileName, lineNumber, startColumn, lineNumber, endColumn, "Found '{0}'", token);
                        }
                        else
                        {
                            message = message.TrimStart(": ".ToCharArray()).TrimEnd();
                            Log.LogWarning(null, null, null, fileName, lineNumber, startColumn, lineNumber, endColumn, "Found '{0}': {1}", token, message);
                        }
                    }
                }
            }
        }
    }
}
]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
